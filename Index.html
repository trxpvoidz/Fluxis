<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Fluxis - McEncryptor JS</title>
<style>
  body {
    background: #111;
    color: #eee;
    font-family: monospace, monospace;
    margin: 0; padding: 0;
    display: flex; flex-direction: column; height: 100vh;
  }
  header {
    background: linear-gradient(45deg, #3a3a3a, #1a1a1a);
    padding: 1em;
    font-weight: bold;
    font-size: 1.4em;
    text-align: center;
    user-select: none;
  }
  main {
    flex: 1;
    display: flex;
    flex-direction: column;
    padding: 1em;
    gap: 0.5em;
  }
  #log {
    flex: 1;
    background: #222;
    padding: 1em;
    overflow-y: auto;
    white-space: pre-wrap;
    border-radius: 4px;
  }
  #log a {
    color: #56caff;
    cursor: pointer;
    text-decoration: underline;
  }
  #controls {
    display: flex;
    gap: 1em;
    flex-wrap: wrap;
  }
  button, input[type="file"] {
    padding: 0.5em 1em;
    font-size: 1em;
    background: #333;
    border: none;
    color: #eee;
    border-radius: 4px;
    cursor: pointer;
  }
  button:disabled {
    opacity: 0.4;
    cursor: default;
  }
  #dropzone {
    border: 2px dashed #555;
    border-radius: 8px;
    padding: 2em;
    text-align: center;
    color: #888;
    user-select: none;
  }
  #dropzone.dragover {
    border-color: #56caff;
    color: #56caff;
    background: #111a;
  }
</style>
</head>
<body>
<header>Fluxis - Minecraft Bedrock Pack Encryptor</header>
<main>
  <div id="dropzone">Drag & Drop Minecraft Pack Folder Here or <input type="file" id="folderInput" webkitdirectory directory multiple /></div>
  <div id="controls">
    <input type="file" id="keysFileInput" accept=".db,.txt" />
    <button id="startBtn" disabled>Start Encryption</button>
  </div>
  <div id="log"></div>
</main>

<!-- CryptoJS for AES-ECB & base64 etc -->
<script src="https://cdn.jsdelivr.net/npm/crypto-js@4.1.1/crypto-js.min.js"></script>
<!-- JSZip for ZIP packaging -->
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

<script>
(() => {
  // Config constants
  const EXCLUDE = ["manifest.json", "pack_icon.png"];
  const EXCLUDE_FOLDERS = ["texts"];
  const DEFAULT_KEY = "s5s5ejuDru4uchuF2drUFuthaspAbepE";

  let keysDb = {}; // uuid -> key
  let folderFiles = [];
  let manifestJson = null;
  let manifestUuid = null;

  const logDiv = document.getElementById("log");
  const startBtn = document.getElementById("startBtn");
  const keysFileInput = document.getElementById("keysFileInput");
  const folderInput = document.getElementById("folderInput");
  const dropzone = document.getElementById("dropzone");

  // Logging function with clickable filenames
  function log(msg, filename=null) {
    if (filename) {
      const a = document.createElement("a");
      a.textContent = msg;
      a.href = "#";
      a.onclick = (e) => {
        e.preventDefault();
        const f = folderFiles.find(f => f.name === filename || f.webkitRelativePath.endsWith(filename));
        if (f) {
          f.text().then(text => {
            const win = window.open();
            if(win) {
              win.document.body.style.background = "#111";
              win.document.body.style.color = "#eee";
              win.document.body.style.whiteSpace = "pre-wrap";
              win.document.title = filename;
              win.document.body.textContent = text;
            } else {
              alert("Pop-up blocked. Please allow pop-ups to view file.");
            }
          });
        } else {
          alert("File not found in current pack.");
        }
      };
      logDiv.appendChild(a);
      logDiv.appendChild(document.createTextNode("\n"));
    } else {
      logDiv.appendChild(document.createTextNode(msg + "\n"));
    }
    logDiv.scrollTop = logDiv.scrollHeight;
  }

  // Parse keys.db file format: uuid=key lines
  async function parseKeysDb(file) {
    const text = await file.text();
    keysDb = {};
    const lines = text.split(/\r?\n/);
    for (const line of lines) {
      if (!line.trim() || !line.includes("=")) continue;
      const [uuid, key] = line.trim().split("=");
      if (uuid && key && key.length === 32) {
        keysDb[uuid] = key;
      }
    }
    log(`Loaded ${Object.keys(keysDb).length} keys from keys.db`);
  }

  // Read and parse manifest.json, get UUID
  async function readManifest() {
    const manifestFile = folderFiles.find(f => f.name === "manifest.json" || f.webkitRelativePath.endsWith("/manifest.json"));
    if (!manifestFile) throw new Error("manifest.json not found in the folder");
    const jsonText = await manifestFile.text();
    manifestJson = JSON.parse(jsonText);
    manifestUuid = manifestJson.header && manifestJson.header.uuid;
    if (!manifestUuid) throw new Error("UUID not found in manifest.json header");
    log(`Found manifest UUID: ${manifestUuid}`);
  }

  // Should this file be encrypted?
  function shouldEncrypt(relPath) {
    const lower = relPath.toLowerCase();
    for (const excl of EXCLUDE) {
      if (lower.endsWith(excl)) return false;
    }
    for (const exclFolder of EXCLUDE_FOLDERS) {
      if (lower.includes(`/${exclFolder.toLowerCase()}/`) || lower.startsWith(exclFolder.toLowerCase() + "/")) return false;
    }
    return true;
  }

  // AES-256-CFB-8 encryption using CryptoJS AES-ECB internally (manual implementation)
  function aes256Cfb8Encrypt(keyStr, dataBytes) {
    const key = CryptoJS.enc.Utf8.parse(keyStr);
    let ivBytes = keyStr.substr(0, 16);
    let shiftRegister = CryptoJS.enc.Utf8.parse(ivBytes);

    const output = new Uint8Array(dataBytes.length);

    for (let i = 0; i < dataBytes.length; i++) {
      // Encrypt shift register with AES-ECB, NoPadding
      const encryptedBlock = CryptoJS.AES.encrypt(
        shiftRegister,
        key,
        { mode: CryptoJS.mode.ECB, padding: CryptoJS.pad.NoPadding }
      );
      const cipherWords = encryptedBlock.ciphertext;

      // Extract first byte of encrypted block
      const firstByte = (cipherWords.words[0] >>> 24) & 0xff;

      // XOR plaintext byte with first byte of encrypted block
      const cipherByte = dataBytes[i] ^ firstByte;
      output[i] = cipherByte;

      // Update shift register: shift left 1 byte, append cipherByte
      // Convert WordArray to byte array
      const shiftBytes = [];
      cipherWords.sigBytes; // not used here but for reference

      const srWords = shiftRegister.words;
      for (let w = 0; w < srWords.length; w++) {
        shiftBytes.push((srWords[w] >>> 24) & 0xff);
        shiftBytes.push((srWords[w] >>> 16) & 0xff);
        shiftBytes.push((srWords[w] >>> 8) & 0xff);
        shiftBytes.push(srWords[w] & 0xff);
      }
      // Keep only first 16 bytes (block size)
      shiftBytes.splice(16);

      // Shift left 1 byte
      shiftBytes.shift();
      // Append cipherByte
      shiftBytes.push(cipherByte);

      // Convert back to WordArray
      shiftRegister = CryptoJS.lib.WordArray.create(shiftBytes);
    }

    return output;
  }

  // Generate random 32 char alphanumeric key for file encryption
  function generateKey() {
    const chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890";
    let key = "";
    for(let i=0; i<32; i++) {
      key += chars.charAt(Math.floor(Math.random()*chars.length));
    }
    return key;
  }

  // Get relative path for file (with webkitRelativePath fallback)
  function getRelPath(file) {
    return file.webkitRelativePath || file.name;
  }

  // Main encryption function
  async function encryptPack() {
    log("Starting encryption...");

    let contentKey = keysDb[manifestUuid] || DEFAULT_KEY;
    log(`Using content key: ${contentKey}`);

    const zip = new JSZip();

    const contentsJson = {
      version: 1,
      content: []
    };

    if (folderFiles.length === 0) {
      log("No files loaded!");
      startBtn.disabled = false;
      return;
    }

    // Determine root folder name from first file
    let firstRel = getRelPath(folderFiles[0]).replace(/\\/g, "/");
    let rootFolderName = firstRel.includes("/") ? firstRel.split("/")[0] : "packroot";
    log(`Root folder in ZIP will be: ${rootFolderName}`);

    for (const file of folderFiles) {
      try {
        const relPathRaw = getRelPath(file).replace(/\\/g, "/");

        // Strip root folder prefix for inside-pack path
        const insidePackRelPath = relPathRaw.startsWith(rootFolderName + "/")
          ? relPathRaw.slice(rootFolderName.length + 1)
          : relPathRaw;

        // Detect directories (type="" and ends with / in relative path)
        const isDir = file.type === "" && relPathRaw.endsWith("/");
        const encryptThis = shouldEncrypt(relPathRaw);

        if (isDir) {
          // Add directory as entry with trailing slash (not encrypted)
          contentsJson.content.push({ path: insidePackRelPath + "/" });
          log(`Directory: ${insidePackRelPath}/ (not encrypted)`);
          continue;
        }

        // Read file bytes
        const data = new Uint8Array(await file.arrayBuffer());

        if (encryptThis) {
          // Generate random file key for AES-256-CFB-8 encryption
          const fileKey = generateKey();
          const encryptedData = aes256Cfb8Encrypt(fileKey, data);

          // Add encrypted file inside root folder
          zip.file(`${rootFolderName}/${insidePackRelPath}`, encryptedData);

          // Add to contents.json with key
          contentsJson.content.push({ path: insidePackRelPath, key: fileKey });

          log(`Encrypted file: ${insidePackRelPath} with key ${fileKey}`);
        } else {
          // Add plain file
          zip.file(`${rootFolderName}/${insidePackRelPath}`, data);

          // Add to contents.json without key
          contentsJson.content.push({ path: insidePackRelPath });

          log(`Skipped encryption for: ${insidePackRelPath}`);
        }
      } catch (e) {
        log(`Error encrypting ${file.name}: ${e.message}`);
      }
    }

    // Encrypt contents.json itself with contentKey (same AES-256-CFB-8)
    const contentsStr = JSON.stringify(contentsJson, null, 2);
    const contentsBytes = new TextEncoder().encode(contentsStr);
    const encryptedContents = aes256Cfb8Encrypt(contentKey, contentsBytes);
    zip.file("contents.json", encryptedContents);

    log("Added encrypted contents.json at ZIP root");

    log("Generating zip...");
    const contentZip = await zip.generateAsync({ type: "blob" });

    const dlLink = document.createElement("a");
    dlLink.href = URL.createObjectURL(contentZip);
    dlLink.download = `${manifestUuid || "pack"}_encrypted.zip`;
    dlLink.textContent = "Download Encrypted Pack ZIP";
    dlLink.style.display = "block";
    dlLink.style.marginTop = "1em";

    document.body.appendChild(dlLink);

    log("Encryption complete! Click the download link above.");
    startBtn.disabled = false;
  }

  // Check if ready to enable start button
  function checkReady() {
    startBtn.disabled = !folderFiles.length || !manifestUuid;
  }

  // Load dropped/selected folder files
  async function loadFolderFiles(filesList) {
    folderFiles = [];
    for (const file of filesList) {
      folderFiles.push(file);
    }
    log(`Loaded ${folderFiles.length} files from folder.`);

    try {
      await readManifest();
      checkReady();
    } catch (ex) {
      log("Error reading manifest.json: " + ex.message);
      manifestUuid = null;
      checkReady();
    }
  }

  // Drag & drop handlers for folders
  dropzone.addEventListener("dragover", e => {
    e.preventDefault();
    dropzone.classList.add("dragover");
  });
  dropzone.addEventListener("dragleave", e => {
    dropzone.classList.remove("dragover");
  });
  dropzone.addEventListener("drop", e => {
    e.preventDefault();
    dropzone.classList.remove("dragover");
    if (e.dataTransfer.items) {
      const files = [];
      const traverseFileTree = async (item, path = "") => {
        if (item.isFile) {
          const file = await new Promise(resolve => item.file(resolve));
          file.webkitRelativePath = path + file.name;
          files.push(file);
        } else if (item.isDirectory) {
          const dirReader = item.createReader();
          let entries = await new Promise(res => dirReader.readEntries(res));
          for (const entry of entries) {
            await traverseFileTree(entry, path + item.name + "/");
          }
        }
      };

      const items = [...e.dataTransfer.items];
      Promise.all(items.map(item => traverseFileTree(item.webkitGetAsEntry()))).then(() => {
        loadFolderFiles(files);
      });
    } else {
      loadFolderFiles(e.dataTransfer.files);
    }
  });

  // Folder input change
  folderInput.addEventListener("change", e => {
    loadFolderFiles(e.target.files);
  });

  // Keys db file input change
  keysFileInput.addEventListener("change", e => {
    const f = e.target.files[0];
    if (!f) return;
    parseKeysDb(f);
  });

  // Start encryption button click
  startBtn.addEventListener("click", () => {
    startBtn.disabled = true;
    encryptPack();
  });

  log("Ready. Drag & drop a Minecraft pack folder or select folder using the picker.");
  log("Load a keys.db file if you want to use custom keys.");

})();
</script>
</body>
</html>
