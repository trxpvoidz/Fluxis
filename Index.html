<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>McEncryptor AES-256-CFB-8</title>
<style>
  body {
    margin: 0; padding: 0; background: #0e0e0e;
    font-family: 'Consolas', monospace;
    color: #eee;
    user-select: none;
  }
  header {
    background: linear-gradient(90deg, #7f00ff, #e100ff);
    text-align: center;
    padding: 15px 10px;
    font-weight: 700;
    font-size: 1.5em;
    color: #fff;
    letter-spacing: 1.1px;
  }
  #drop-area {
    border: 3px dashed #7f00ff;
    margin: 20px auto;
    max-width: 600px;
    padding: 30px;
    text-align: center;
    cursor: pointer;
    transition: background-color 0.3s;
    border-radius: 10px;
  }
  #drop-area.hover {
    background-color: #330044;
  }
  #fileElem {
    display: none;
  }
  button {
    background: #7f00ff;
    border: none;
    padding: 10px 20px;
    color: white;
    font-size: 1.1em;
    cursor: pointer;
    border-radius: 6px;
    margin-top: 10px;
  }
  #log {
    max-width: 600px;
    margin: 10px auto 40px;
    height: 320px;
    background: #111;
    border-radius: 8px;
    overflow-y: auto;
    padding: 12px;
    font-size: 0.9em;
    line-height: 1.3em;
  }
  #log div {
    cursor: default;
  }
  #log div.file {
    color: #aaffaa;
    cursor: pointer;
    text-decoration: underline;
  }
  #progress-bar {
    width: 600px;
    max-width: 90vw;
    margin: 0 auto 20px;
    height: 16px;
    background: #222;
    border-radius: 8px;
    overflow: hidden;
  }
  #progress {
    height: 100%;
    width: 0%;
    background: linear-gradient(90deg, #7f00ff, #e100ff);
    transition: width 0.3s ease;
  }
  @media (max-width: 640px) {
    #drop-area, #log, #progress-bar {
      max-width: 95vw;
    }
  }
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jszip@3.7.1/dist/jszip.min.js"></script>
</head>
<body>
<header>McEncryptor AES-256-CFB-8</header>

<div id="drop-area">
  <p>Drag & Drop your Minecraft pack folder here or click to select files</p>
  <input type="file" id="fileElem" webkitdirectory directory multiple />
  <button id="selectBtn">Select Folder</button>
</div>

<div id="progress-bar"><div id="progress"></div></div>

<div id="log"></div>

<script>
(() => {
  "use strict";

  // Constants from your C# code
  const AES_KEY = "s5s5ejuDru4uchuF2drUFuthaspAbepE"; // 32 chars
  const AES_IV = "s5s5ejuDru4uchuF"; // 16 chars

  // Convert key/iv to WordArray for CryptoJS
  const keyWA = CryptoJS.enc.Utf8.parse(AES_KEY);
  const ivWA = CryptoJS.enc.Utf8.parse(AES_IV);

  // Helper to read file as Uint8Array
  function readFileAsUint8Array(file) {
    return new Promise((resolve, reject) => {
      const fr = new FileReader();
      fr.onload = () => resolve(new Uint8Array(fr.result));
      fr.onerror = reject;
      fr.readAsArrayBuffer(file);
    });
  }

  // Generate random 32-char alphanumeric key for contents.json entries
  function generateRandomKey() {
    const chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890";
    let key = "";
    for (let i = 0; i < 32; i++) {
      key += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return key;
  }

  // Encode Uint8Array to base64 string
  function base64FromUint8(arr) {
    return btoa(String.fromCharCode(...arr));
  }

  // Decode base64 to Uint8Array
  function uint8FromBase64(str) {
    const binary = atob(str);
    const len = binary.length;
    const arr = new Uint8Array(len);
    for(let i = 0; i < len; i++) {
      arr[i] = binary.charCodeAt(i);
    }
    return arr;
  }

  // AES-256-CFB-8 encrypt using CryptoJS AES-ECB primitive + manual CFB8 feedback
  function aes256cfb8Encrypt(plaintextBytes, keyWA, ivWA) {
    // Shift register init (copy IV)
    let shiftRegister = ivWA.words.slice(0);

    // AES ECB encrypt function from CryptoJS
    const ecbEncrypt = (blockWords) => {
      const block = CryptoJS.lib.WordArray.create(blockWords, 16);
      const encrypted = CryptoJS.AES.encrypt(block, keyWA, {mode: CryptoJS.mode.ECB, padding: CryptoJS.pad.NoPadding});
      return encrypted.ciphertext.words;
    };

    const blockSize = 16; // AES block size bytes
    const ptLen = plaintextBytes.length;
    let ciphertext = new Uint8Array(ptLen);

    // Convert shiftRegister to Uint8Array for easy shifting
    function wordsToBytes(words) {
      const bytes = new Uint8Array(words.length * 4);
      for(let i = 0; i < words.length; i++) {
        bytes[i*4] = (words[i] >>> 24) & 0xff;
        bytes[i*4+1] = (words[i] >>> 16) & 0xff;
        bytes[i*4+2] = (words[i] >>> 8) & 0xff;
        bytes[i*4+3] = words[i] & 0xff;
      }
      return bytes;
    }
    function bytesToWords(bytes) {
      const words = [];
      for(let i = 0; i < bytes.length; i += 4) {
        words.push(
          (bytes[i] << 24) | (bytes[i+1] << 16) | (bytes[i+2] << 8) | bytes[i+3]
        );
      }
      return words;
    }

    let shiftBytes = wordsToBytes(shiftRegister);

    for (let i = 0; i < ptLen; i++) {
      // Encrypt current shift register (ECB)
      let encryptedSRWords = ecbEncrypt(bytesToWords(shiftBytes));
      let encryptedSRBytes = wordsToBytes(encryptedSRWords);

      // Take first byte of encrypted shift register as key byte
      let keyByte = encryptedSRBytes[0];

      // XOR with plaintext byte
      let ctByte = plaintextBytes[i] ^ keyByte;
      ciphertext[i] = ctByte;

      // Shift left shift register by 1 byte and append ciphertext byte
      shiftBytes.copyWithin(0, 1);
      shiftBytes[blockSize - 1] = ctByte;
    }

    return ciphertext;
  }

  // The decrypt function is identical in CFB mode except feedback uses ciphertext, so
  // to decrypt ciphertext, you use same logic but XOR ciphertext with encrypted shift register,
  // then shift register shifts by ciphertext bytes.
  function aes256cfb8Decrypt(ciphertextBytes, keyWA, ivWA) {
    // Shift register init (copy IV)
    let shiftRegister = ivWA.words.slice(0);

    const ecbEncrypt = (blockWords) => {
      const block = CryptoJS.lib.WordArray.create(blockWords, 16);
      const encrypted = CryptoJS.AES.encrypt(block, keyWA, {mode: CryptoJS.mode.ECB, padding: CryptoJS.pad.NoPadding});
      return encrypted.ciphertext.words;
    };

    const blockSize = 16;
    const ctLen = ciphertextBytes.length;
    let plaintext = new Uint8Array(ctLen);

    function wordsToBytes(words) {
      const bytes = new Uint8Array(words.length * 4);
      for(let i = 0; i < words.length; i++) {
        bytes[i*4] = (words[i] >>> 24) & 0xff;
        bytes[i*4+1] = (words[i] >>> 16) & 0xff;
        bytes[i*4+2] = (words[i] >>> 8) & 0xff;
        bytes[i*4+3] = words[i] & 0xff;
      }
      return bytes;
    }
    function bytesToWords(bytes) {
      const words = [];
      for(let i = 0; i < bytes.length; i += 4) {
        words.push(
          (bytes[i] << 24) | (bytes[i+1] << 16) | (bytes[i+2] << 8) | bytes[i+3]
        );
      }
      return words;
    }

    let shiftBytes = wordsToBytes(shiftRegister);

    for(let i = 0; i < ctLen; i++) {
      let encryptedSRWords = ecbEncrypt(bytesToWords(shiftBytes));
      let encryptedSRBytes = wordsToBytes(encryptedSRWords);

      let keyByte = encryptedSRBytes[0];
      let ptByte = ciphertextBytes[i] ^ keyByte;
      plaintext[i] = ptByte;

      shiftBytes.copyWithin(0, 1);
      shiftBytes[blockSize - 1] = ciphertextBytes[i];
    }

    return plaintext;
  }

  // File exclusion rules
  // skip encrypting manifest.json, pack_icon.png, any file inside texts/
  function shouldEncrypt(filePath) {
    const lower = filePath.toLowerCase().replace(/\\/g, '/');
    if(lower.endsWith("manifest.json")) return false;
    if(lower.endsWith("pack_icon.png")) return false;
    if(lower.includes("/texts/")) return false;
    return true;
  }

  // Generates contents.json structure
  // input: array of {path: string, encrypted: bool, key: string|null, content: Uint8Array}
  function generateContentsJson(files) {
    // version=1 always
    // content array of entries:
    // if encrypted: { "key": "keystring", "path": "relative/path" }
    // else: { "path": "relative/path" }

    const content = [];
    for(const file of files) {
      if(file.encrypted) {
        content.push({ key: file.key, path: file.path });
      } else {
        content.push({ path: file.path });
      }
    }
    return {
      version: 1,
      content
    };
  }

  // Generates signatures.json (flat array [{path, hash}])
  // Hash is SHA256 of encrypted file content in base64
  async function generateSignaturesJson(files) {
    const signatures = [];
    for (const file of files) {
      const data = file.encrypted ? file.encryptedData : file.content;
      const hashBuffer = await crypto.subtle.digest('SHA-256', data);
      const hashArray = new Uint8Array(hashBuffer);
      const hashB64 = btoa(String.fromCharCode(...hashArray));
      signatures.push({ path: file.path, hash: hashB64 });
    }
    return signatures;
  }

  // Encrypt and package everything into a ZIP, then prompt download
  async function processFiles(fileList) {
    logClear();
    log(`Processing ${fileList.length} files...`);

    // Map relative paths => files & content
    // fileList: array of File objects with webkitRelativePath or relativePath
    // fallback: build relative path from file.name only if relative path missing
    // convert File -> {path, content Uint8Array, encrypted, key (if encrypted), encryptedData}

    const filesData = [];
    const usedKeys = new Set();

    for (const file of fileList) {
      const relativePath = file.webkitRelativePath || file.relativePath || file.name;
      const lowerRel = relativePath.toLowerCase().replace(/\\/g, '/');

      if (file.size === 0) {
        log(`Skipping empty file: ${relativePath}`);
        continue;
      }

      const content = new Uint8Array(await readFileAsUint8Array(file));

      if(shouldEncrypt(relativePath)) {
        // encrypt

        // Generate unique random key (32 chars alnum)
        let key;
        do {
          key = generateRandomKey();
        } while (usedKeys.has(key));
        usedKeys.add(key);

        // encrypt content with AES-256-CFB-8
        const encryptedContent = aes256cfb8Encrypt(content, CryptoJS.enc.Utf8.parse(key), ivWA);

        filesData.push({
          path: relativePath,
          content,
          encrypted: true,
          key: key,
          encryptedData: encryptedContent
        });
        logFile(relativePath, true);
      } else {
        // don't encrypt
        filesData.push({
          path: relativePath,
          content,
          encrypted: false,
          key: null,
          encryptedData: null
        });
        logFile(relativePath, false);
      }
    }

    // Generate contents.json (with keys for encrypted files)
    const contentsJson = generateContentsJson(filesData);
    const contentsJsonStr = JSON.stringify(contentsJson, null, 2);
    const contentsJsonBytes = new TextEncoder().encode(contentsJsonStr);

    // Encrypt contents.json with AES-256-CFB-8 with your constant key
    const contentsEncryptedBytes = aes256cfb8Encrypt(contentsJsonBytes, keyWA, ivWA);

    // Add contents.json to filesData (unencrypted path, encrypted content, key=null)
    filesData.push({
      path: "contents.json",
      content: contentsJsonBytes,
      encrypted: true,
      key: null,
      encryptedData: contentsEncryptedBytes
    });

    // Generate signatures.json
    const signaturesJson = await generateSignaturesJson(filesData);
    const signaturesJsonStr = JSON.stringify(signaturesJson, null, 2);
    const signaturesJsonBytes = new TextEncoder().encode(signaturesJsonStr);

    // Encrypt signatures.json with AES-256-CFB-8 with your constant key
    const signaturesEncryptedBytes = aes256cfb8Encrypt(signaturesJsonBytes, keyWA, ivWA);

    filesData.push({
      path: "signatures.json",
      content: signaturesJsonBytes,
      encrypted: true,
      key: null,
      encryptedData: signaturesEncryptedBytes
    });

    // Create ZIP file with JSZip
    const zip = new JSZip();

    for(const file of filesData) {
      if(file.encrypted) {
        zip.file(file.path, file.encryptedData);
      } else {
        zip.file(file.path, file.content);
      }
    }

    log("Generating ZIP...");
    const blob = await zip.generateAsync({type: "blob"});
    log("ZIP generated!");

    // Download file
    const now = new Date();
    const filename = `encrypted_pack_${now.getFullYear()}${(now.getMonth()+1).toString().padStart(2,"0")}${now.getDate().toString().padStart(2,"0")}.zip`;

    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();

    log("Done!");
  }

  // Console log functions
  const logEl = document.getElementById("log");
  function log(msg) {
    const div = document.createElement("div");
    div.textContent = msg;
    logEl.appendChild(div);
    logEl.scrollTop = logEl.scrollHeight;
  }
  function logFile(filename, encrypted) {
    const div = document.createElement("div");
    div.textContent = filename + (encrypted ? " (encrypted)" : " (skipped)");
    if(encrypted) div.classList.add("file");
    div.title = "Click to open file location (if supported)";
    div.onclick = () => {
      alert(`File: ${filename}`);
      // No direct file open possible in browser sandbox
    };
    logEl.appendChild(div);
    logEl.scrollTop = logEl.scrollHeight;
  }
  function logClear() {
    logEl.innerHTML = "";
  }

  // Progress bar
  const progressBar = document.getElementById("progress");
  function setProgress(percent) {
    progressBar.style.width = percent + "%";
  }

  // UI elements
  const dropArea = document.getElementById("drop-area");
  const fileElem = document.getElementById("fileElem");
  const selectBtn = document.getElementById("selectBtn");

  selectBtn.onclick = () => fileElem.click();

  dropArea.addEventListener("dragenter", e => {
    e.preventDefault();
    dropArea.classList.add("hover");
  });
  dropArea.addEventListener("dragover", e => {
    e.preventDefault();
   
