<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Fluxis Pack Encryptor</title>
  <style>
    body {
      background: #0a0a0a;
      color: white;
      font-family: 'Segoe UI', sans-serif;
      text-align: center;
      padding: 20px;
    }
    h1 {
      font-size: 2em;
      background: linear-gradient(90deg, #6af, #a6f);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow: 0 0 10px #6af;
    }
    #dropzone {
      border: 2px dashed #aaa;
      padding: 40px;
      margin: 20px;
      border-radius: 10px;
      cursor: pointer;
    }
    input[type="checkbox"] {
      margin-right: 8px;
    }
    pre#log {
      text-align: left;
      margin: 10px auto;
      max-width: 600px;
      background: #111;
      padding: 10px;
      border-radius: 6px;
      font-size: 0.85em;
      overflow-x: auto;
    }
    progress {
      width: 80%;
      margin-top: 10px;
    }
    button {
      margin-top: 12px;
      background: #222;
      color: white;
      border: 1px solid #555;
      padding: 8px 16px;
      border-radius: 5px;
      cursor: pointer;
    }
    button:hover {
      background: #333;
    }
  </style>
</head>
<body>
  <h1>Fluxis Pack Encryptor</h1>
  <div id="dropzone">Drop your Minecraft pack folder here<br/>or tap to select on mobile</div>
  <input type="file" id="filePicker" webkitdirectory directory multiple hidden />
  <label><input type="checkbox" id="backupToggle" checked>Enable Backup</label><br/>
  <label><input type="checkbox" id="dontEncrypt">Don't Encrypt (for testing)</label>
  <pre id="log"></pre>
  <progress id="progressBar" value="0" max="100"></progress><br/>
  <button onclick="startEncryption()">Start Encryption</button>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script>
    const KEY = CryptoJS.enc.Utf8.parse("s5s5ejuDru4uchuF2drUFuthaspAbepE");
    const IV = CryptoJS.enc.Utf8.parse("s5s5ejuDru4uchuF");
    let files = {};

    const log = (msg) => {
      const el = document.getElementById("log");
      el.textContent += msg + "\\n";
      el.scrollTop = el.scrollHeight;
    };

    const isExcluded = (path) => {
      const lower = path.toLowerCase();
      return lower.endsWith("manifest.json") ||
             lower.endsWith("pack_icon.png") ||
             lower.startsWith("texts/");
    };

    document.getElementById("dropzone").addEventListener("click", () => {
      document.getElementById("filePicker").click();
    });

    document.getElementById("filePicker").addEventListener("change", (event) => {
      files = {};
      for (const f of event.target.files) {
        files[f.webkitRelativePath] = f;
      }
      log("Loaded " + Object.keys(files).length + " files.");
    });

    function sha256Base64(buffer) {
      const wordArray = CryptoJS.lib.WordArray.create(buffer);
      const hash = CryptoJS.SHA256(wordArray);
      return CryptoJS.enc.Base64.stringify(hash);
    }

    async function encryptBytes(data) {
      const wordArray = CryptoJS.lib.WordArray.create(data);
      const encrypted = CryptoJS.AES.encrypt(wordArray, KEY, {
        iv: IV,
        mode: CryptoJS.mode.CFB,
        padding: CryptoJS.pad.NoPadding
      });
      return CryptoJS.enc.Base64.parse(encrypted.ciphertext.toString(CryptoJS.enc.Base64)).toString(CryptoJS.enc.Base64);
    }

    async function startEncryption() {
      const zip = new JSZip();
      const shouldEncrypt = !document.getElementById("dontEncrypt").checked;
      const contentIndex = [];
      const signatureIndex = [];

      const filePaths = Object.keys(files);
      if (filePaths.length === 0) {
        log("No files loaded.");
        return;
      }

      let processed = 0;
      for (const path of filePaths) {
        const file = files[path];
        const content = await file.arrayBuffer();
        const relPath = path.replace(/^.*?\\//, "").replace(/\\/g, "/");

        if (relPath === "") continue;

        let encrypted = content;

        if (!isExcluded(relPath)) {
          if (shouldEncrypt) {
            const encryptedBase64 = await encryptBytes(content);
            encrypted = Uint8Array.from(atob(encryptedBase64), c => c.charCodeAt(0));
          }
          contentIndex.push({ path: relPath, key: relPath }); // key same as path
        }

        const hash = sha256Base64(new Uint8Array(content));
        signatureIndex.push({ path: relPath, hash });

        zip.file(relPath, encrypted);
        log("Processed: " + relPath);
        processed++;
        document.getElementById("progressBar").value = (processed / filePaths.length) * 100;
      }

      // Generate contents.json & signatures.json
      const contentsStr = JSON.stringify(contentIndex, null, 2);
      const signaturesStr = JSON.stringify(signatureIndex, null, 2);
      let contentsBlob = new TextEncoder().encode(contentsStr);
      let signaturesBlob = new TextEncoder().encode(signaturesStr);

      if (shouldEncrypt) {
        const encContents = await encryptBytes(contentsBlob);
        const encSignatures = await encryptBytes(signaturesBlob);
        contentsBlob = Uint8Array.from(atob(encContents), c => c.charCodeAt(0));
        signaturesBlob = Uint8Array.from(atob(encSignatures), c => c.charCodeAt(0));
      }

      zip.file("contents.json", contentsBlob);
      zip.file("signatures.json", signaturesBlob);

      const zipBlob = await zip.generateAsync({ type: "blob" });
      const url = URL.createObjectURL(zipBlob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "encrypted_pack.zip";
      a.click();
      URL.revokeObjectURL(url);
      log("Encryption complete. Download started.");
    }
  </script>
</body>
</html>
