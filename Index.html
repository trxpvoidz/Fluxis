<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Fluxis Encryptor</title>
  <style>
    body {
      background: #0a0a0a;
      color: white;
      font-family: 'Segoe UI', sans-serif;
      text-align: center;
      padding: 20px;
    }
    h1 {
      font-size: 2.5em;
      background: linear-gradient(90deg, #ff00cc, #3333ff);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: glow 2s ease-in-out infinite alternate;
    }
    @keyframes glow {
      from { text-shadow: 0 0 5px #ff00cc; }
      to { text-shadow: 0 0 20px #3333ff; }
    }
    #drop-zone {
      border: 2px dashed #888;
      padding: 40px;
      margin-top: 20px;
      border-radius: 10px;
    }
    input, label, button {
      margin: 10px;
      padding: 10px;
      border: none;
      border-radius: 5px;
    }
    #progress {
      width: 100%;
      background: #333;
      margin-top: 20px;
    }
    #progress-bar {
      height: 20px;
      background: linear-gradient(90deg, #00f260, #0575e6);
      width: 0%;
    }
  </style>
</head>
<body>
  <h1>Fluxis Encryptor</h1>
  <label>
    <input type="checkbox" id="backupToggle"> Enable Backup
  </label>
  <div id="drop-zone">Drop your MCBE pack folder here</div>
  <div id="progress">
    <div id="progress-bar"></div>
  </div>
  <pre id="manifest-preview"></pre>

  <script>
    const AES_KEY = 's5s5ejuDru4uchuF2drUFuthaspAbepE';
    const AES_IV = 's5s5ejuDru4uchuF';
    const encoder = new TextEncoder();

    document.getElementById('drop-zone').addEventListener('drop', handleDrop);
    document.getElementById('drop-zone').addEventListener('dragover', e => e.preventDefault());

    async function handleDrop(e) {
      e.preventDefault();
      const backupEnabled = document.getElementById('backupToggle').checked;
      const items = [...e.dataTransfer.items];
      const entry = items[0].webkitGetAsEntry();
      if (!entry.isDirectory) {
        alert('Drop a folder only.');
        return;
      }

      const packFiles = await readDirectory(entry);
      const manifestFile = packFiles.find(f => f.name === 'manifest.json');
      if (!manifestFile) return alert('Missing manifest.json');

      const manifestText = await manifestFile.file.text();
      document.getElementById('manifest-preview').textContent = manifestText;

      const manifestHash = await sha1(manifestText);
      const contents = [];
      const fileData = {};

      let processed = 0;
      for (const f of packFiles) {
        const data = await f.file.arrayBuffer();
        const hash = await sha1(data);
        contents.push({
          path: f.path,
          hash: hash,
          size: data.byteLength
        });
        fileData[f.path] = new Uint8Array(data);
        processed++;
        updateProgress((processed / packFiles.length) * 100);
      }

      const contentsJSON = JSON.stringify(contents, null, 2);
      const signatureJSON = JSON.stringify({
        version: 1,
        signature: btoa(await encrypt(contentsJSON))
      }, null, 2);

      fileData['contents.json'] = encoder.encode(contentsJSON);
      fileData['signature.json'] = encoder.encode(signatureJSON);

      if (backupEnabled) await createBackup(packFiles);

      downloadZip(fileData, 'Encrypted_Pack.zip');
    }

    async function readDirectory(entry, path = '') {
      return new Promise(resolve => {
        const reader = entry.createReader();
        const entries = [];
        function readEntries() {
          reader.readEntries(async results => {
            if (!results.length) {
              const files = [];
              for (const e of entries) {
                if (e.isFile) {
                  files.push(await getFileEntry(e, path));
                } else if (e.isDirectory) {
                  const sub = await readDirectory(e, path + e.name + '/');
                  files.push(...sub);
                }
              }
              resolve(files);
            } else {
              entries.push(...results);
              readEntries();
            }
          });
        }
        readEntries();
      });
    }

    async function getFileEntry(entry, base) {
      return new Promise(resolve => {
        entry.file(file => resolve({ path: base + file.name, file, name: file.name }));
      });
    }

    async function sha1(input) {
      const buffer = (input instanceof ArrayBuffer) ? input : encoder.encode(input);
      const hash = await crypto.subtle.digest('SHA-1', buffer);
      return [...new Uint8Array(hash)].map(b => b.toString(16).padStart(2, '0')).join('');
    }

    async function encrypt(text) {
      const key = await crypto.subtle.importKey(
        'raw', encoder.encode(AES_KEY), { name: 'AES-CBC' }, false, ['encrypt']
      );
      const iv = encoder.encode(AES_IV);
      const ciphertext = await crypto.subtle.encrypt({ name: 'AES-CBC', iv }, key, encoder.encode(text));
      return String.fromCharCode(...new Uint8Array(ciphertext));
    }

    function updateProgress(percent) {
      document.getElementById('progress-bar').style.width = percent + '%';
    }

    async function createBackup(files) {
      const zipData = {};
      for (const f of files) {
        const data = await f.file.arrayBuffer();
        zipData[f.path] = new Uint8Array(data);
      }
      downloadZip(zipData, 'Backup_Pack.zip');
    }

    function downloadZip(files, filename) {
      const zip = new JSZip();
      for (const path in files) {
        zip.file(path, files[path]);
      }
      zip.generateAsync({ type: 'blob' }).then(blob => {
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = filename;
        link.click();
      });
    }
  </script>

  <!-- Include JSZip -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
</body>
</html>
