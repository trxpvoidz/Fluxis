<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Fluxis - McEncryptor JS</title>
<style>
  body {
    background: #111;
    color: #eee;
    font-family: monospace, monospace;
    margin: 0; padding: 0;
    display: flex; flex-direction: column; height: 100vh;
  }
  header {
    background: linear-gradient(45deg, #3a3a3a, #1a1a1a);
    padding: 1em;
    font-weight: bold;
    font-size: 1.4em;
    text-align: center;
    user-select: none;
  }
  main {
    flex: 1;
    display: flex;
    flex-direction: column;
    padding: 1em;
    gap: 0.5em;
  }
  #log {
    flex: 1;
    background: #222;
    padding: 1em;
    overflow-y: auto;
    white-space: pre-wrap;
    border-radius: 4px;
  }
  #log a {
    color: #56caff;
    cursor: pointer;
    text-decoration: underline;
  }
  #controls {
    display: flex;
    gap: 1em;
    flex-wrap: wrap;
  }
  button, input[type="file"] {
    padding: 0.5em 1em;
    font-size: 1em;
    background: #333;
    border: none;
    color: #eee;
    border-radius: 4px;
    cursor: pointer;
  }
  button:disabled {
    opacity: 0.4;
    cursor: default;
  }
  #dropzone {
    border: 2px dashed #555;
    border-radius: 8px;
    padding: 2em;
    text-align: center;
    color: #888;
    user-select: none;
  }
  #dropzone.dragover {
    border-color: #56caff;
    color: #56caff;
    background: #111a;
  }
</style>
</head>
<body>
<header>Fluxis - Minecraft Bedrock Pack Encryptor</header>
<main>
  <div id="dropzone">Drag & Drop Minecraft Pack Folder Here or <input type="file" id="folderInput" webkitdirectory directory multiple /></div>
  <div id="controls">
    <input type="file" id="keysFileInput" accept=".db,.txt" />
    <button id="startBtn" disabled>Start Encryption</button>
  </div>
  <div id="log"></div>
</main>

<script src="https://cdn.jsdelivr.net/npm/crypto-js@4.1.1/crypto-js.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

<script>
(() => {
  // Config
  const EXCLUDE = ["manifest.json", "pack_icon.png"];
  const EXCLUDE_FOLDERS = ["texts"];

  // Default key if none found in keys.db
  const DEFAULT_KEY = "s5s5ejuDru4uchuF2drUFuthaspAbepE";

  // Globals
  let keysDb = {}; // { uuid: key }
  let folderFiles = []; // array of File objects from folder input/dragdrop
  let manifestJson = null;
  let manifestUuid = null;

  const logDiv = document.getElementById("log");
  const startBtn = document.getElementById("startBtn");
  const keysFileInput = document.getElementById("keysFileInput");
  const folderInput = document.getElementById("folderInput");
  const dropzone = document.getElementById("dropzone");

  // Logging helper
  function log(msg, filename=null) {
    if (filename) {
      const a = document.createElement("a");
      a.textContent = msg;
      a.href = "#";
      a.onclick = (e) => {
        e.preventDefault();
        const f = folderFiles.find(f => f.name === filename || f.webkitRelativePath.endsWith(filename));
        if (f) {
          f.text().then(text => {
            const win = window.open();
            if(win) {
              win.document.body.style.background = "#111";
              win.document.body.style.color = "#eee";
              win.document.body.style.whiteSpace = "pre-wrap";
              win.document.title = filename;
              win.document.body.textContent = text;
            } else {
              alert("Pop-up blocked. Please allow pop-ups to view file.");
            }
          });
        } else {
          alert("File not found in current pack.");
        }
      };
      logDiv.appendChild(a);
      logDiv.appendChild(document.createTextNode("\n"));
    } else {
      logDiv.appendChild(document.createTextNode(msg + "\n"));
    }
    logDiv.scrollTop = logDiv.scrollHeight;
  }

  // Parse keys.db text into keysDb object
  async function parseKeysDb(file) {
    const text = await file.text();
    keysDb = {};
    const lines = text.split(/\r?\n/);
    for (const line of lines) {
      if (!line.trim() || !line.includes("=")) continue;
      const [uuid, key] = line.trim().split("=");
      if (uuid && key && key.length === 32) {
        keysDb[uuid] = key;
      }
    }
    log(`Loaded ${Object.keys(keysDb).length} keys from keys.db`);
  }

  // Read manifest.json, parse UUID
  async function readManifest() {
    const manifestFile = folderFiles.find(f => f.name === "manifest.json" || f.webkitRelativePath.endsWith("/manifest.json"));
    if (!manifestFile) throw new Error("manifest.json not found in the folder");
    const jsonText = await manifestFile.text();
    manifestJson = JSON.parse(jsonText);
    manifestUuid = manifestJson.header && manifestJson.header.uuid;
    if (!manifestUuid) throw new Error("UUID not found in manifest.json header");
    log(`Found manifest UUID: ${manifestUuid}`);
  }

  // Utility: filter out files we shouldn't encrypt
  function shouldEncrypt(relPath) {
    const lower = relPath.toLowerCase();
    for (const excl of EXCLUDE) {
      if (lower.endsWith(excl)) return false;
    }
    for (const exclFolder of EXCLUDE_FOLDERS) {
      if (lower.includes(`/${exclFolder.toLowerCase()}/`) || lower.startsWith(exclFolder.toLowerCase() + "/")) return false;
    }
    return true;
  }

  // AES-256-CFB encrypt with CryptoJS (using CTR mode as approximation)
  function aes256CfbEncrypt(keyStr, dataBytes) {
    const key = CryptoJS.enc.Utf8.parse(keyStr);
    const iv = CryptoJS.enc.Utf8.parse(keyStr.substr(0,16));
    const wordArray = CryptoJS.lib.WordArray.create(dataBytes);
    const encrypted = CryptoJS.AES.encrypt(wordArray, key, {
      iv: iv,
      mode: CryptoJS.mode.CTR,
      padding: CryptoJS.pad.NoPadding
    });
    // Convert base64 ciphertext to Uint8Array
    const base64str = encrypted.toString();
    const parsedWords = CryptoJS.enc.Base64.parse(base64str);
    const words = parsedWords.words;
    const sigBytes = parsedWords.sigBytes;
    const result = new Uint8Array(sigBytes);
    let i = 0;
    for (let w=0; w < words.length; w++) {
      if (i >= sigBytes) break;
      result[i++] = (words[w] >>> 24) & 0xFF;
      if (i >= sigBytes) break;
      result[i++] = (words[w] >>> 16) & 0xFF;
      if (i >= sigBytes) break;
      result[i++] = (words[w] >>> 8) & 0xFF;
      if (i >= sigBytes) break;
      result[i++] = words[w] & 0xFF;
    }
    return result;
  }

  // Generate random 32-char alphanumeric key
  function generateKey() {
    const chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890";
    let key = "";
    for(let i=0; i<32; i++) {
      key += chars.charAt(Math.floor(Math.random()*chars.length));
    }
    return key;
  }

  // Build relative path for a File object
  function getRelPath(file) {
    return file.webkitRelativePath || file.name;
  }

  async function encryptPack() {
    log("Starting encryption...");

    let contentKey = keysDb[manifestUuid] || DEFAULT_KEY;
    log(`Using content key: ${contentKey}`);

    const zip = new JSZip();

    const contentsJson = {
      version: 1,
      content: []
    };

    if (folderFiles.length === 0) {
      log("No files loaded!");
      return;
    }

    // Determine root folder inside dropped folder files for proper zip structure
    let firstRel = getRelPath(folderFiles[0]).replace(/\\/g, "/");
    let rootFolderName = firstRel.includes("/") ? firstRel.split("/")[0] : "";

    for (const file of folderFiles) {
      const relPathRaw = getRelPath(file).replace(/\\/g, "/");
      // Remove root folder prefix for inside ZIP paths
      const insidePackRelPath = rootFolderName ? relPathRaw.startsWith(rootFolderName + "/")
        ? relPathRaw.slice(rootFolderName.length + 1)
        : relPathRaw : relPathRaw;

      const isDir = file.type === "" && relPathRaw.endsWith("/");
      const encryptThis = shouldEncrypt(relPathRaw);

      if (isDir) {
        contentsJson.content.push({ path: insidePackRelPath + "/" });
        log(`Directory: ${insidePackRelPath}/ (not encrypted)`);
        continue;
      }

      const data = new Uint8Array(await file.arrayBuffer());

      if (encryptThis) {
        const key = generateKey();
        const encryptedData = aes256CfbEncrypt(key, data);
        zip.file(`${rootFolderName}/${insidePackRelPath}`, encryptedData);
        contentsJson.content.push({ path: insidePackRelPath, key });
        log(`Encrypted file: ${insidePackRelPath} with key ${key}`);
      } else {
        zip.file(`${rootFolderName}/${insidePackRelPath}`, data);
        contentsJson.content.push({ path: insidePackRelPath });
        log(`Skipped encryption for: ${insidePackRelPath}`);
      }
    }

    // Add contents.json to content list with no key
    contentsJson.content.push({ path: "contents.json" });

    // Encrypt contents.json with the shared contentKey
    const contentsJsonString = JSON.stringify(contentsJson, null, 2);
    const contentsJsonBytes = new TextEncoder().encode(contentsJsonString);
    const encryptedContentsJson = aes256CfbEncrypt(contentKey, contentsJsonBytes);
    zip.file("contents.json", encryptedContentsJson);

    log("Added encrypted contents.json at ZIP root");

    log("Generating zip...");
    const contentZip = await zip.generateAsync({ type: "blob" });

    const dlLink = document.createElement("a");
    dlLink.href = URL.createObjectURL(contentZip);
    dlLink.download = `${manifestUuid || "pack"}_encrypted.zip`;
    dlLink.textContent = "Download Encrypted Pack ZIP";
    dlLink.style.display = "block";
    dlLink.style.marginTop = "1em";

    document.body.appendChild(dlLink);

    log("Encryption complete! Click the download link above.");
    startBtn.disabled = false;
  }

  // Enable start button only when folder loaded & manifest found
  function checkReady() {
    startBtn.disabled = !folderFiles.length || !manifestUuid;
  }

  // Load folder files on drag/drop or file input
  async function loadFolderFiles(filesList) {
    folderFiles = [];
    for (const file of filesList) {
      folderFiles.push(file);
    }
    log(`Loaded ${folderFiles.length} files from folder.`);

    try {
      await readManifest();
      checkReady();
    } catch (ex) {
      log("Error reading manifest.json: " + ex.message);
      manifestUuid = null;
      checkReady();
    }
  }

  // Drag & drop handlers
  dropzone.addEventListener("dragover", e => {
    e.preventDefault();
    dropzone.classList.add("dragover");
  });
  dropzone.addEventListener("dragleave", e => {
    dropzone.classList.remove("dragover");
  });
  dropzone.addEventListener("drop", e => {
    e.preventDefault();
    dropzone.classList.remove("dragover");
    if (e.dataTransfer.items) {
      const files = [];
      const traverseFileTree = async (item, path = "") => {
        if (item.isFile) {
          const file = await new Promise(resolve => item.file(resolve));
          file.webkitRelativePath = path + file.name;
          files.push(file);
        } else if (item.isDirectory) {
          const dirReader = item.createReader();
          let entries = await new Promise(res => dirReader.readEntries(res));
          for (const entry of entries) {
            await traverseFileTree(entry, path + item.name + "/");
          }
        }
      };

      const items = [...e.dataTransfer.items];
      Promise.all(items.map(item => traverseFileTree(item.webkitGetAsEntry()))).then(() => {
        loadFolderFiles(files);
      });
    } else {
      loadFolderFiles(e.dataTransfer.files);
    }
  });

  // File input change handlers
  folderInput.addEventListener("change", e => {
    loadFolderFiles(e.target.files);
  });

  keysFileInput.addEventListener("change", e => {
    const f = e.target.files[0];
    if (!f) return;
    parseKeysDb(f);
  });

  startBtn.addEventListener("click", () => {
    startBtn.disabled = true;
    encryptPack();
  });

  log("Ready. Drag & drop a Minecraft pack folder or select folder using the picker.");
  log("Load a keys.db file if you want to use custom keys.");

})();
</script>
</body>
</html>
