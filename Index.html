<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Minecraft Encryptor</title>
  <style>
    body {
      margin: 0;
      font-family: monospace;
      background: linear-gradient(to bottom right, #101010, #202020);
      color: #0f0;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    header {
      width: 100%;
      background: linear-gradient(to right, #00f260, #0575e6);
      padding: 12px 0;
      text-align: center;
      font-size: 22px;
      font-weight: bold;
      color: black;
    }
    #drop-zone {
      border: 2px dashed #0f0;
      border-radius: 12px;
      margin: 20px;
      padding: 40px;
      text-align: center;
      width: 90%;
      max-width: 600px;
    }
    #logs {
      width: 90%;
      max-width: 600px;
      height: 200px;
      background: #000;
      overflow-y: auto;
      padding: 10px;
      font-size: 12px;
      border: 1px solid #0f0;
      margin-bottom: 20px;
      white-space: pre-wrap;
    }
    button {
      background: #0f0;
      color: black;
      border: none;
      padding: 10px 20px;
      font-weight: bold;
      cursor: pointer;
      border-radius: 6px;
    }
    button:hover {
      background: #0c0;
    }
  </style>
</head>
<body>

<header>üõ°Ô∏è McEncryptor (Web)</header>

<div id="drop-zone">Drop your Minecraft pack folder or zip here</div>
<div id="logs">Log initialized...</div>
<button id="download-btn" style="display:none;">Download Encrypted ZIP</button>

<script>
  const encoder = new TextEncoder();
  const decoder = new TextDecoder();
  const universalKey = "s5s5ejuDru4uchuF2drUFuthaspAbepE";
  const universalIV = universalKey.slice(0, 16);
  const log = msg => {
    const logs = document.getElementById("logs");
    logs.textContent += "\n" + msg;
    logs.scrollTop = logs.scrollHeight;
  };

  const toHex = buffer => [...new Uint8Array(buffer)].map(b => b.toString(16).padStart(2, '0')).join('');
  const toBase64 = buffer => btoa(String.fromCharCode(...new Uint8Array(buffer)));
  const randomKey = () => [...crypto.getRandomValues(new Uint8Array(32))].map(b => "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"[b % 62]).join('');

  async function sha256(buffer) {
    const hash = await crypto.subtle.digest("SHA-256", buffer);
    return toBase64(hash);
  }

  async function aesEncryptCFB(keyStr, ivStr, dataBuffer) {
    const key = await crypto.subtle.importKey("raw", encoder.encode(keyStr), {name: "AES-CFB"}, false, ["encrypt"]);
    const encrypted = await crypto.subtle.encrypt({name: "AES-CFB", iv: encoder.encode(ivStr)}, key, dataBuffer);
    return new Uint8Array(encrypted);
  }

  function isExcluded(path) {
    return path.endsWith("manifest.json") || path.endsWith("pack_icon.png") || path.startsWith("texts/");
  }

  async function handleFiles(entries) {
    const JSZip = (await import('https://cdn.jsdelivr.net/npm/jszip/+esm')).default;
    const zip = new JSZip();
    const contentList = [];
    const signatureList = [];
    let manifestUUID = "";

    const files = {};
    const gatherFiles = async entry => {
      if (entry.isFile) {
        const path = entry.fullPath.replace(/^\//, "");
        const file = await new Promise(resolve => entry.file(resolve));
        files[path] = file;
      } else if (entry.isDirectory) {
        const reader = entry.createReader();
        const entries = await new Promise(resolve => reader.readEntries(resolve));
        for (const ent of entries) await gatherFiles(ent);
      }
    };

    for (const item of entries) {
      const entry = item.webkitGetAsEntry();
      if (entry) await gatherFiles(entry);
    }

    const manifestFile = files["manifest.json"];
    if (!manifestFile) return log("manifest.json not found!");
    const manifestText = await manifestFile.text();
    const manifestJson = JSON.parse(manifestText);
    manifestUUID = manifestJson.header?.uuid || "";

    signatureList.push({
      path: "manifest.json",
      hash: await sha256(await manifestFile.arrayBuffer())
    });

    const zipOut = new JSZip();

    for (const [path, file] of Object.entries(files)) {
      if (path === "contents.json") continue;
      if (path === "signatures.json") continue;
      const data = await file.arrayBuffer();

      if (isExcluded(path)) {
        zipOut.file(path, new Uint8Array(data));
        contentList.push({ path });
        log(`Excluded: ${path}`);
      } else {
        const key = randomKey();
        const iv = key.slice(0, 16);
        const encrypted = await aesEncryptCFB(key, iv, data);
        zipOut.file(path, encrypted);
        contentList.push({ path, key });
        log(`Encrypted: ${path}`);
      }
    }

    // Add signatures.json
    const signatureJson = JSON.stringify(signatureList);
    const sigKey = randomKey();
    const sigIV = sigKey.slice(0, 16);
    const sigEncrypted = await aesEncryptCFB(sigKey, sigIV, encoder.encode(signatureJson));
    zipOut.file("signatures.json", sigEncrypted);
    contentList.push({ path: "signatures.json", key: sigKey });

    // Add contents.json entry (only after signing signatures.json)
    const contentsEntry = JSON.stringify({
      version: 1,
      content: contentList
    });

    // Encrypt contents.json
    const contentsBytes = encoder.encode(contentsEntry);
    const encryptedContents = await aesEncryptCFB(universalKey, universalIV, contentsBytes);

    // Build 256-byte prefix
    const prefix = new Uint8Array(256);
    prefix.set([0x00, 0x00, 0x00, 0x00, 0xFC, 0xB9, 0xCF, 0x9B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], 0);
    prefix[16] = 0x24;
    const uuidBytes = encoder.encode(manifestUUID);
    prefix.set(uuidBytes, 17);
    const fullContents = new Uint8Array(256 + encryptedContents.length);
    fullContents.set(prefix);
    fullContents.set(encryptedContents, 256);
    zipOut.file("contents.json", fullContents);

    // Generate zip
    const blob = await zipOut.generateAsync({ type: "blob" });
    const url = URL.createObjectURL(blob);
    const dl = document.getElementById("download-btn");
    dl.style.display = "inline-block";
    dl.onclick = () => {
      const a = document.createElement("a");
      a.href = url;
      a.download = "encrypted_pack.zip";
      a.click();
    };

    log("‚úÖ Done! Encrypted ZIP ready.");
  }

  const dropZone = document.getElementById("drop-zone");
  dropZone.addEventListener("dragover", e => {
    e.preventDefault();
    dropZone.style.borderColor = "#0c0";
  });
  dropZone.addEventListener("dragleave", () => {
    dropZone.style.borderColor = "#0f0";
  });
  dropZone.addEventListener("drop", async e => {
    e.preventDefault();
    dropZone.style.borderColor = "#0f0";
    const items = [...e.dataTransfer.items].filter(i => i.kind === "file");
    log("Processing dropped files...");
    await handleFiles(items);
  });
</script>

</body>
</html>
