<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Fluxis Encryptor</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    body {
      background: #0a0a0a;
      color: white;
      font-family: 'Segoe UI', sans-serif;
      text-align: center;
      padding: 20px;
    }
    h1 {
      font-size: 2em;
      background: linear-gradient(90deg, #6af, #a6f);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow: 0 0 10px #6af;
    }
    #dropzone {
      border: 2px dashed #aaa;
      padding: 40px;
      margin: 20px;
      border-radius: 10px;
      cursor: pointer;
    }
    #log {
      text-align: left;
      max-height: 200px;
      overflow: auto;
      font-family: monospace;
      background: #111;
      padding: 10px;
      margin: 10px auto;
      border-radius: 8px;
      width: 90%;
      font-size: 0.85em;
    }
    button {
      margin-top: 12px;
      background: #222;
      color: white;
      border: 1px solid #555;
      padding: 8px 16px;
      border-radius: 5px;
      cursor: pointer;
    }
    button:hover {
      background: #333;
    }
    input[type="file"] {
      display: none;
    }
  </style>
</head>
<body>
  <h1>Fluxis Pack Encryptor</h1>
  <div id="dropzone">üìÅ Drop folder or zip here<br/>or click to choose</div>
  <input type="file" id="filePicker" webkitdirectory directory multiple />
  <input type="file" id="zipPicker" accept=".zip" />
  <br>
  <button onclick="startEncryption()">Start Encryption</button>
  <div id="log"></div>

  <script>
    const key = new TextEncoder().encode("s5s5ejuDru4uchuF2drUFuthaspAbepE");
    const iv = new TextEncoder().encode("s5s5ejuDru4uchuF");

    const dropzone = document.getElementById("dropzone");
    const filePicker = document.getElementById("filePicker");
    const zipPicker = document.getElementById("zipPicker");
    const logBox = document.getElementById("log");

    let inputFiles = [];

    dropzone.onclick = () => filePicker.click();
    filePicker.onchange = e => {
      inputFiles = [...e.target.files];
      log("üìÅ Folder selected: " + inputFiles.length + " files");
    };
    zipPicker.onchange = e => {
      const file = e.target.files[0];
      if (!file || !file.name.endsWith(".zip")) return;
      JSZip.loadAsync(file).then(zip => {
        zip.forEach((path, file) => {
          file.async("uint8array").then(data => {
            const fakeFile = new File([data], path);
            inputFiles.push(fakeFile);
          });
        });
        log("üì¶ Zip loaded");
      });
    };

    dropzone.ondragover = e => {
      e.preventDefault();
      dropzone.style.borderColor = "#6af";
    };
    dropzone.ondragleave = () => {
      dropzone.style.borderColor = "#aaa";
    };
    dropzone.ondrop = e => {
      e.preventDefault();
      dropzone.style.borderColor = "#aaa";

      const items = [...e.dataTransfer.items];
      inputFiles = [];

      const queue = items.map(item => {
        const entry = item.webkitGetAsEntry?.();
        if (entry && entry.isDirectory) {
          return readAllFiles(entry);
        } else {
          return Promise.resolve([item.getAsFile()]);
        }
      });

      Promise.all(queue).then(flat => {
        inputFiles = flat.flat();
        log("üìÅ Dropped: " + inputFiles.length + " files");
      });
    };

    function readAllFiles(entry, path = "") {
      return new Promise(resolve => {
        const reader = entry.createReader();
        reader.readEntries(entries => {
          const promises = entries.map(e => {
            if (e.isFile) {
              return new Promise(res => {
                e.file(f => {
                  f.fullPath = path + e.name;
                  res(f);
                });
              });
            } else {
              return readAllFiles(e, path + e.name + "/");
            }
          });
          Promise.all(promises).then(r => resolve(r.flat()));
        });
      });
    }

    async function startEncryption() {
      if (!inputFiles.length) return log("‚ö†Ô∏è No files to encrypt.");

      const zip = new JSZip();
      const contents = [];
      const signatures = [];

      for (const file of inputFiles) {
        const rawPath = file.webkitRelativePath || file.fullPath || file.name;
        const normPath = rawPath.replace(/^.*?\/?/, "");

        if (
          normPath === "manifest.json" ||
          normPath === "pack_icon.png" ||
          normPath.startsWith("texts/")
        ) {
          zip.file(normPath, file);
          log("‚ö™ Skipped (no encryption): " + normPath);
          continue;
        }

        const buffer = await file.arrayBuffer();
        const data = new Uint8Array(buffer);
        const encrypted = await aesEncrypt(data, key, iv);

        zip.file(normPath, encrypted);
        log("üîê Encrypted: " + normPath);

        const hashBuffer = await crypto.subtle.digest("SHA-256", encrypted);
        const hashBase64 = btoa(String.fromCharCode(...new Uint8Array(hashBuffer)));

        contents.push({ path: normPath });
        signatures.push({ path: normPath, hash: hashBase64 });
      }

      const contentsJson = new TextEncoder().encode(JSON.stringify({ key: "default", files: contents }, null, 2));
      const signaturesJson = new TextEncoder().encode(JSON.stringify(signatures, null, 2));

      const encContents = await aesEncrypt(contentsJson, key, iv);
      const encSignatures = await aesEncrypt(signaturesJson, key, iv);

      zip.file("contents.json", encContents);
      zip.file("signatures.json", encSignatures);
      log("‚úÖ Encrypted contents.json and signatures.json");

      zip.generateAsync({ type: "blob" }).then(blob => {
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = "encrypted_pack.zip";
        a.click();
        log("üéâ Done! Download started.");
      });
    }

    async function aesEncrypt(data, key, iv) {
      const cryptoKey = await crypto.subtle.importKey("raw", key, "AES-CFB", false, ["encrypt"]);
      const encrypted = await crypto.subtle.encrypt({ name: "AES-CFB", iv }, cryptoKey, data);
      return new Uint8Array(encrypted);
    }

    function log(msg) {
      const line = document.createElement("div");
      line.textContent = msg;
      logBox.appendChild(line);
      logBox.scrollTop = logBox.scrollHeight;
    }
  </script>
</body>
</html>
