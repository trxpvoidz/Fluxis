<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Fluxis Encryptor</title>
  <style>
    body {
      margin: 0;
      background: #0e0e0e;
      font-family: 'Segoe UI', sans-serif;
      color: white;
      text-align: center;
      padding: 20px;
    }
    h1 {
      font-size: 2.5em;
      background: linear-gradient(90deg, #8f44fd, #00ffff, #ff44cc);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: glow 2s infinite alternate;
    }
    @keyframes glow {
      from { text-shadow: 0 0 5px #8f44fd; }
      to { text-shadow: 0 0 15px #00ffff; }
    }
    #dropzone {
      border: 2px dashed #444;
      border-radius: 8px;
      padding: 40px;
      margin: 30px auto;
      width: 60%;
      background: #1a1a1a;
      transition: 0.3s ease;
    }
    #dropzone.dragover {
      background-color: #222;
      border-color: #888;
    }
    label, input, button {
      margin: 12px;
      display: inline-block;
    }
    input[type="file"] {
      display: none;
    }
    #progressBar {
      width: 80%;
      height: 16px;
      margin: 20px auto;
      background: #333;
      border-radius: 5px;
    }
    #progressBarFill {
      width: 0%;
      height: 100%;
      background: linear-gradient(to right, #00ffff, #8f44fd);
      border-radius: 5px;
      transition: width 0.3s ease;
    }
  </style>
</head>
<body>
  <h1>Fluxis</h1>
  <p><strong>MCBE Pack Encryptor</strong> â€” Built to match McTools behavior</p>

  <label><input type="checkbox" id="backupOption" checked> Backup before encrypting</label>

  <div id="dropzone">Drag and drop your pack folder here</div>
  <div id="progressBar"><div id="progressBarFill"></div></div>
  <input type="file" id="folderInput" webkitdirectory directory multiple>
  <br><button onclick="document.getElementById('folderInput').click()">Choose Folder</button>

  <script>
    const key = "s5s5ejuDru4uchuF2drUFuthaspAbepE";
    const iv = "s5s5ejuDru4uchuF";

    const dropzone = document.getElementById("dropzone");
    const progress = document.getElementById("progressBarFill");

    dropzone.addEventListener("dragover", e => {
      e.preventDefault();
      dropzone.classList.add("dragover");
    });

    dropzone.addEventListener("dragleave", () => {
      dropzone.classList.remove("dragover");
    });

    dropzone.addEventListener("drop", async e => {
      e.preventDefault();
      dropzone.classList.remove("dragover");
      const items = e.dataTransfer.items;
      const entries = [];
      for (const item of items) {
        const entry = item.webkitGetAsEntry?.();
        if (entry?.isDirectory) {
          entries.push(entry);
        }
      }
      if (entries.length) {
        handleFolderDrop(entries[0]);
      }
    });

    document.getElementById("folderInput").addEventListener("change", async e => {
      const files = Array.from(e.target.files);
      const base = files[0].webkitRelativePath.split("/")[0];
      await processFiles(files, base);
    });

    async function handleFolderDrop(entry) {
      const reader = entry.createReader();
      let entries = [];
      let readEntries = () => new Promise(resolve => reader.readEntries(resolve));
      let batch;
      do {
        batch = await readEntries();
        entries = entries.concat(batch);
      } while (batch.length);
      const files = await Promise.all(entries.map(e => new Promise(resolve => e.file(resolve))));
      const base = entry.name;
      await processFiles(files, base);
    }

    async function processFiles(files, baseFolderName) {
      progress.style.width = "5%";
      const fileMap = {};
      for (const file of files) {
        fileMap[file.webkitRelativePath || file.name] = file;
      }

      // Read manifest
      const manifestPath = Object.keys(fileMap).find(k => k.endsWith("manifest.json"));
      if (!manifestPath) return alert("manifest.json not found.");
      const manifest = JSON.parse(await fileMap[manifestPath].text());
      const uuid = manifest.header.uuid;

      // Create backup
      if (document.getElementById("backupOption").checked) {
        const zip = new JSZip();
        for (const path in fileMap) {
          zip.file(path.replace(`${baseFolderName}/`, ""), fileMap[path]);
        }
        const backupBlob = await zip.generateAsync({type: "blob"});
        const backupUrl = URL.createObjectURL(backupBlob);
        const a = document.createElement("a");
        a.href = backupUrl;
        a.download = `${baseFolderName}_backup.zip`;
        a.click();
        progress.style.width = "15%";
      }

      // Sign manifest
      manifest.signature = "Fluxis Signed Manifest";
      const updatedManifestBlob = new Blob([JSON.stringify(manifest, null, 2)], { type: "application/json" });

      // Generate contents.json
      const contents = [];
      for (const [path, file] of Object.entries(fileMap)) {
        const arrayBuffer = await file.arrayBuffer();
        const hash = await crypto.subtle.digest("SHA-1", arrayBuffer);
        const hashHex = Array.from(new Uint8Array(hash)).map(b => b.toString(16).padStart(2, "0")).join("");
        contents.push({ file: path.replace(baseFolderName + "/", ""), hash: hashHex });
      }
      const contentsBlob = new Blob([JSON.stringify(contents, null, 2)], { type: "application/json" });

      progress.style.width = "50%";

      // Encrypt files using AES-CBC
      const aesKey = await crypto.subtle.importKey("raw", new TextEncoder().encode(key), { name: "AES-CBC" }, false, ["encrypt"]);
      const encryptedFiles = {};

      for (const [path, file] of Object.entries(fileMap)) {
        const ivBytes = new TextEncoder().encode(iv);
        const encrypted = await crypto.subtle.encrypt({ name: "AES-CBC", iv: ivBytes }, aesKey, await file.arrayBuffer());
        encryptedFiles[path.replace(baseFolderName + "/", "")] = new Uint8Array(encrypted);
      }

      progress.style.width = "75%";

      // Create final pack zip
      const finalZip = new JSZip();
      for (const [name, data] of Object.entries(encryptedFiles)) {
        finalZip.file(name, data);
      }
      finalZip.file("manifest.json", updatedManifestBlob);
      finalZip.file("contents.json", contentsBlob);
      finalZip.file("signature.json", new Blob([JSON.stringify({ signature: "Fluxis Signed", uuid })], { type: "application/json" }));

      const blob = await finalZip.generateAsync({ type: "blob" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `${baseFolderName}_encrypted.mcpack`;
      a.click();

      progress.style.width = "100%";
    }
  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
</body>
</html>
