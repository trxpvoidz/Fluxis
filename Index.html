<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Fluxis</title>
<style>
  body {
    background: #111;
    color: #fff;
    font-family: sans-serif;
    text-align: center;
    padding: 20px;
  }
  #dropzone {
    margin: 20px auto;
    border: 3px dashed #888;
    border-radius: 10px;
    width: 80%;
    max-width: 600px;
    height: 200px;
    line-height: 200px;
    color: #666;
    font-size: 24px;
    user-select: none;
  }
  #dropzone.dragover {
    border-color: #0f0;
    color: #0f0;
    background: #222;
  }
  button {
    margin-top: 20px;
    padding: 10px 20px;
    font-size: 18px;
    cursor: pointer;
  }
  pre {
    background: #222;
    padding: 10px;
    max-height: 300px;
    overflow-y: auto;
    text-align: left;
    font-size: 14px;
    border-radius: 6px;
    white-space: pre-wrap;
  }
</style>
</head>
<body>

<h1>Fluxis</h1>

<div id="dropzone">Drag & Drop your skin pack files here</div>

<button id="generateBtn" disabled>Generate & Encrypt JSON Files</button>

<h2>Generated JSON Preview (unencrypted)</h2>
<pre id="previewContents"></pre>
<pre id="previewSignatures"></pre>

<script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
<script>
(() => {
  const keyStr = "s5s5ejuDru4uchuF2drUFuthaspAbepE";
  const ivStr = "s5s5ejuDru4uchuF";

  const key = CryptoJS.enc.Utf8.parse(keyStr);
  const iv = CryptoJS.enc.Utf8.parse(ivStr);

  const dropzone = document.getElementById("dropzone");
  const generateBtn = document.getElementById("generateBtn");
  const previewContents = document.getElementById("previewContents");
  const previewSignatures = document.getElementById("previewSignatures");

  let filesMap = new Map();

  dropzone.addEventListener("dragover", e => {
    e.preventDefault();
    dropzone.classList.add("dragover");
  });

  dropzone.addEventListener("dragleave", e => {
    e.preventDefault();
    dropzone.classList.remove("dragover");
  });

  dropzone.addEventListener("drop", e => {
    e.preventDefault();
    dropzone.classList.remove("dragover");

    filesMap.clear();

    const items = e.dataTransfer.items;

    if (!items) {
      alert("Drag and drop not supported in this browser");
      return;
    }

    let filePromises = [];

    const traverseFileTree = (item, path = "") => {
      return new Promise((resolve) => {
        if (item.isFile) {
          item.file(file => {
            filesMap.set(path + file.name, file);
            resolve();
          });
        } else if (item.isDirectory) {
          const dirReader = item.createReader();
          dirReader.readEntries(entries => {
            Promise.all(entries.map(entry => traverseFileTree(entry, path + item.name + "/"))).then(() => resolve());
          });
        } else {
          resolve();
        }
      });
    };

    const itemPromises = [];
    for (let i = 0; i < items.length; i++) {
      const item = items[i].webkitGetAsEntry();
      if (item) {
        itemPromises.push(traverseFileTree(item));
      }
    }

    Promise.all(itemPromises).then(() => {
      if (filesMap.size === 0) {
        alert("No files detected");
        generateBtn.disabled = true;
      } else {
        generateBtn.disabled = false;
        alert(`Loaded ${filesMap.size} files`);
      }
    });
  });

  function generateContentsJson(filesMap) {
    function randomKey() {
      const chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
      let res = "";
      for (let i = 0; i < 32; i++) {
        res += chars.charAt(Math.floor(Math.random() * chars.length));
      }
      return res;
    }

    const contentArr = [];
    const paths = Array.from(filesMap.keys()).sort();

    for (const path of paths) {
      const lower = path.toLowerCase();

      if (lower.endsWith("/")) {
        contentArr.push({ path: path });
        continue;
      }

      if (lower === "manifest.json") {
        contentArr.push({ path: path });
        continue;
      }

      const key = randomKey();
      contentArr.push({ key, path });
    }

    return {
      version: 1,
      content: contentArr,
    };
  }

  async function generateSignaturesJson(filesMap) {
    const signatureArr = [];
    const paths = Array.from(filesMap.keys());

    for (const path of paths) {
      const file = filesMap.get(path);
      if (!file) continue;

      const hash = await getFileHash(file);
      signatureArr.push({ path, hash });
    }

    return signatureArr;
  }

  async function getFileHash(file) {
    const arrayBuffer = await file.arrayBuffer();
    const wordArray = CryptoJS.lib.WordArray.create(arrayBuffer);
    const hash = CryptoJS.SHA256(wordArray);
    return CryptoJS.enc.Base64.stringify(hash);
  }

  function encryptString(plaintext) {
    const encrypted = CryptoJS.AES.encrypt(plaintext, key, { iv: iv, mode: CryptoJS.mode.CFB, padding: CryptoJS.pad.NoPadding });
    return encrypted.ciphertext.toString(CryptoJS.enc.Base64);
  }

  function downloadFile(filename, contents) {
    const blob = new Blob([contents], { type: "application/octet-stream" });
    const link = document.createElement("a");
    link.href = URL.createObjectURL(blob);
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }

  generateBtn.addEventListener("click", async () => {
    generateBtn.disabled = true;

    const contentsJsonObj = generateContentsJson(filesMap);
    const contentsJsonStr = JSON.stringify(contentsJsonObj, null, 2);

    const signaturesJsonArr = await generateSignaturesJson(filesMap);
    const signaturesJsonStr = JSON.stringify(signaturesJsonArr);

    previewContents.textContent = contentsJsonStr;
    previewSignatures.textContent = signaturesJsonStr;

    const encryptedContents = encryptString(contentsJsonStr);
    const encryptedSignatures = encryptString(signaturesJsonStr);

    downloadFile("contents.json", encryptedContents);
    downloadFile("signatures.json", encryptedSignatures);

    alert("Encrypted contents.json and signatures.json downloaded!");

    generateBtn.disabled = false;
  });

})();
</script>
</body>
</html>
