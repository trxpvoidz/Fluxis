<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Fluxis Encryptor</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: monospace;
      background: linear-gradient(135deg, #111, #222);
      color: white;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
    }
    h1 {
      margin-top: 10px;
    }
    #drop-area {
      border: 2px dashed #888;
      padding: 40px;
      width: 80%;
      max-width: 600px;
      text-align: center;
      margin-bottom: 20px;
      cursor: pointer;
    }
    #log {
      background: #000;
      width: 90%;
      max-width: 700px;
      padding: 10px;
      height: 200px;
      overflow-y: auto;
      font-size: 13px;
    }
    progress {
      width: 80%;
      margin: 10px;
    }
    button {
      background: #444;
      color: white;
      padding: 10px;
      border: none;
      cursor: pointer;
    }
    @media (max-width: 600px) {
      #drop-area {
        padding: 20px;
        font-size: 14px;
      }
    }
  </style>
</head>
<body>
  <h1>Fluxis Encryptor</h1>
  <div id="drop-area">
    <p>Click or drop your Minecraft folder here</p>
    <input type="file" id="fileElem" webkitdirectory directory multiple hidden>
  </div>
  <progress id="progressBar" value="0" max="100"></progress>
  <pre id="log">[Fluxis] Ready.</pre>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
  <script>
    const dropArea = document.getElementById("drop-area");
    const fileElem = document.getElementById("fileElem");
    const log = document.getElementById("log");
    const progress = document.getElementById("progressBar");

    const KEY = CryptoJS.enc.Utf8.parse("s5s5ejuDru4uchuF2drUFuthaspAbepE");
    const IV = CryptoJS.enc.Utf8.parse("s5s5ejuDru4uchuF");

    function logMessage(msg) {
      log.textContent += `\n${msg}`;
      log.scrollTop = log.scrollHeight;
    }

    dropArea.addEventListener("click", () => fileElem.click());
    dropArea.addEventListener("dragover", e => {
      e.preventDefault();
      dropArea.style.borderColor = "#0f0";
    });
    dropArea.addEventListener("dragleave", () => {
      dropArea.style.borderColor = "#888";
    });
    dropArea.addEventListener("drop", e => {
      e.preventDefault();
      handleFiles(e.dataTransfer.files);
    });
    fileElem.addEventListener("change", e => {
      handleFiles(e.target.files);
    });

    function handleFiles(fileList) {
      const files = Array.from(fileList);
      const zip = new JSZip();
      const contentsJson = [];
      const signatures = [];

      const excludedPaths = ["manifest.json", "pack_icon.png"];
      files.forEach(file => {
        if (file.webkitRelativePath.includes("texts/")) {
          excludedPaths.push(file.webkitRelativePath);
        }
      });

      const total = files.length;
      let processed = 0;

      logMessage("[Fluxis] Starting encryption...");

      const processFile = (index) => {
        if (index >= total) {
          logMessage("[Fluxis] Finalizing...");
          finalize();
          return;
        }

        const file = files[index];
        const relativePath = file.webkitRelativePath || file.name;
        const reader = new FileReader();
        reader.onload = () => {
          const content = new Uint8Array(reader.result);
          const base64 = CryptoJS.enc.Base64.stringify(CryptoJS.lib.WordArray.create(content));
          const hash = CryptoJS.SHA256(CryptoJS.enc.Base64.parse(base64)).toString(CryptoJS.enc.Base64);

          signatures.push({ hash, path: relativePath.replace(/\\/g, "/") });

          if (excludedPaths.includes(relativePath)) {
            zip.file(relativePath, content);
            logMessage(`[Exclude] ${relativePath}`);
          } else {
            const encrypted = CryptoJS.AES.encrypt(CryptoJS.lib.WordArray.create(content), KEY, {
              iv: IV,
              mode: CryptoJS.mode.CFB,
              padding: CryptoJS.pad.NoPadding
            }).ciphertext;

            const encryptedUint8 = new Uint8Array(encrypted.words.length * 4);
            for (let i = 0; i < encrypted.words.length; i++) {
              const word = encrypted.words[i];
              encryptedUint8.set([
                (word >> 24) & 0xff,
                (word >> 16) & 0xff,
                (word >> 8) & 0xff,
                word & 0xff
              ], i * 4);
            }

            zip.file(relativePath, encryptedUint8);
            contentsJson.push({ path: relativePath, key: KEY.toString(CryptoJS.enc.Base64) });
            logMessage(`[Encrypt] ${relativePath}`);
          }

          progress.value = ((index + 1) / total) * 100;
          processFile(index + 1);
        };
        reader.readAsArrayBuffer(file);
      };

      processFile(0);

      function finalize() {
        const contentsBlob = new Blob([JSON.stringify(contentsJson)], { type: "application/json" });
        const sigBlob = new Blob([JSON.stringify(signatures)], { type: "application/json" });

        const reader1 = new FileReader();
        reader1.onload = () => {
          const enc1 = CryptoJS.AES.encrypt(
            CryptoJS.lib.WordArray.create(reader1.result),
            KEY,
            { iv: IV, mode: CryptoJS.mode.CFB, padding: CryptoJS.pad.NoPadding }
          ).ciphertext;

          const reader2 = new FileReader();
          reader2.onload = () => {
            const enc2 = CryptoJS.AES.encrypt(
              CryptoJS.lib.WordArray.create(reader2.result),
              KEY,
              { iv: IV, mode: CryptoJS.mode.CFB, padding: CryptoJS.pad.NoPadding }
            ).ciphertext;

            const enc1Uint8 = new Uint8Array(enc1.words.length * 4);
            for (let i = 0; i < enc1.words.length; i++) {
              const word = enc1.words[i];
              enc1Uint8.set([(word >> 24) & 0xff, (word >> 16) & 0xff, (word >> 8) & 0xff, word & 0xff], i * 4);
            }

            const enc2Uint8 = new Uint8Array(enc2.words.length * 4);
            for (let i = 0; i < enc2.words.length; i++) {
              const word = enc2.words[i];
              enc2Uint8.set([(word >> 24) & 0xff, (word >> 16) & 0xff, (word >> 8) & 0xff, word & 0xff], i * 4);
            }

            zip.file("contents.json", enc1Uint8);
            zip.file("signatures.json", enc2Uint8);

            zip.generateAsync({ type: "blob" }).then(blob => {
              const a = document.createElement("a");
              a.href = URL.createObjectURL(blob);
              a.download = "encrypted_pack.zip";
              a.click();
              logMessage("[Fluxis] âœ… Done. Downloaded as .zip.");
            });
          };
          reader2.readAsArrayBuffer(sigBlob);
        };
        reader1.readAsArrayBuffer(contentsBlob);
      }
    }
  </script>
</body>
</html>
