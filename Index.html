<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Fluxis Pack Encryptor</title>
  <style>
    body {
      background: #0a0a0a;
      color: white;
      font-family: 'Segoe UI', sans-serif;
      text-align: center;
      padding: 20px;
    }
    h1 {
      font-size: 2em;
      background: linear-gradient(90deg, #6af, #a6f);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow: 0 0 10px #6af;
    }
    #dropzone {
      border: 2px dashed #aaa;
      padding: 40px;
      margin: 20px;
      border-radius: 10px;
      cursor: pointer;
    }
    input[type="checkbox"] {
      margin-right: 8px;
    }
    #manifestPreview {
      margin: 10px auto;
      white-space: pre-wrap;
      max-width: 600px;
      background: #111;
      padding: 10px;
      border-radius: 6px;
      font-size: 0.85em;
    }
    progress {
      width: 80%;
      margin-top: 10px;
    }
    #status {
      margin-top: 8px;
      font-size: 0.9em;
      color: #aaa;
    }
    button {
      margin-top: 12px;
      background: #222;
      color: white;
      border: 1px solid #555;
      padding: 8px 16px;
      border-radius: 5px;
      cursor: pointer;
    }
    button:hover {
      background: #333;
    }
  </style>
</head>
<body>
  <h1>Fluxis Pack Encryptor</h1>
  <div id="dropzone">Drop your Minecraft pack folder here<br/>or tap to select on mobile</div>
  <input type="file" id="filePicker" webkitdirectory directory multiple hidden />
  <label><input type="checkbox" id="backupToggle" checked>Enable Backup</label><br/>
  <label><input type="checkbox" id="dontEncrypt">Don't Encrypt (for testing)</label>
  <pre id="manifestPreview"></pre>
  <progress id="progressBar" value="0" max="100"></progress>
  <div id="status"></div>
  <button onclick="startEncryption()">Start Encryption</button>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/aes-js@3.0.0/index.min.js"></script>
  <script>
    const key = aesjs.utils.utf8.toBytes('s5s5ejuDru4uchuF2drUFuthaspAbepE');
    const iv = aesjs.utils.utf8.toBytes('s5s5ejuDru4uchuF');

    const dropzone = document.getElementById('dropzone');
    const filePicker = document.getElementById('filePicker');
    let files = [];

    dropzone.onclick = () => filePicker.click();
    filePicker.onchange = (e) => {
      files = [...e.target.files];
      displayManifest(files);
    };

    dropzone.ondragover = (e) => {
      e.preventDefault();
      dropzone.style.borderColor = "#6af";
    };
    dropzone.ondragleave = () => {
      dropzone.style.borderColor = "#aaa";
    };
    dropzone.ondrop = (e) => {
      e.preventDefault();
      dropzone.style.borderColor = "#aaa";
      files = [...e.dataTransfer.files];
      displayManifest(files);
    };

    function displayManifest(fileList) {
      const manifestFile = fileList.find(f => f.webkitRelativePath.endsWith('manifest.json'));
      if (!manifestFile) {
        document.getElementById('manifestPreview').textContent = '❌ No manifest.json found.';
        return;
      }
      manifestFile.text().then(txt => {
        document.getElementById('manifestPreview').textContent = txt;
      });
    }

    async function startEncryption() {
      if (!files.length) return alert("Drop or select a pack folder first.");
      const dontEncrypt = document.getElementById('dontEncrypt').checked;
      const backupEnabled = document.getElementById('backupToggle').checked;

      const zip = new JSZip();
      const contents = [];
      const progressBar = document.getElementById('progressBar');
      const status = document.getElementById('status');

      const total = files.length;
      let processed = 0;

      for (const file of files) {
        const relPath = file.webkitRelativePath.split('/').slice(1).join('/');
        const shouldEncrypt = !(
          relPath === "manifest.json" ||
          relPath === "pack_icon.png" ||
          relPath.startsWith("texts/")
        );

        const arrayBuffer = await file.arrayBuffer();
        let data = new Uint8Array(arrayBuffer);

        if (!dontEncrypt && shouldEncrypt) {
          data = encryptCFB(data);
        }

        zip.file(relPath, data);

        const hashBuffer = await crypto.subtle.digest("SHA-1", data);
        const hash = Array.from(new Uint8Array(hashBuffer)).map(b => b.toString(16).padStart(2, '0')).join("");

        contents.push({
          path: relPath.replace(/\\/g, '/'),
          hash: hash
        });

        processed++;
        progressBar.value = Math.round((processed / total) * 100);
        status.textContent = `Encrypting: ${relPath}`;

        if (backupEnabled && processed === Math.floor(total / 2)) {
          await new Promise(res => setTimeout(res, 100));
          const confirmBackup = confirm("Create backup now?");
          if (confirmBackup) {
            saveBackup(files);
          }
        }
      }

      const contentsJSON = JSON.stringify({ files: contents }, null, 2);
      const signatureHash = await crypto.subtle.digest("SHA-256", new TextEncoder().encode(contentsJSON));
      const signature = Array.from(new Uint8Array(signatureHash)).map(b => b.toString(16).padStart(2, '0')).join('');
      const signatureJSON = JSON.stringify({ signature: signature }, null, 2);

      const encryptedContents = encryptCFB(new TextEncoder().encode(contentsJSON));
      const encryptedSignature = encryptCFB(new TextEncoder().encode(signatureJSON));

      zip.file("contents.json", encryptedContents);
      zip.file("signature.json", encryptedSignature);

      zip.generateAsync({ type: "blob" }).then(blob => {
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = "encrypted_pack.zip";
        a.click();
        status.textContent = "✅ Done!";
      });
    }

    function encryptCFB(data) {
      const aesCfb = new aesjs.ModeOfOperation.cfb(key, iv, 16); // 128-bit segment
      return aesCfb.encrypt(data);
    }

    function saveBackup(fileList) {
      const zip = new JSZip();
      for (const file of fileList) {
        const relPath = file.webkitRelativePath.split('/').slice(1).join('/');
        zip.file(relPath, file);
      }
      zip.generateAsync({ type: "blob" }).then(blob => {
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = "backup.zip";
        a.click();
      });
    }
  </script>
</body>
</html>
